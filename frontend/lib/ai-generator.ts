"use client";

export interface DSAQuestion {
    title: string;
    description: string;
    difficulty: string;
    example: {
        input: string;
        output: string;
    };
    testCases: Array<{
        input: string;
        output: string;
    }>;
}

export interface VoiceQuestion {
    question: string;
    answer: string;
}

export interface InterviewContent {
    dsa: DSAQuestion[];
    voice: VoiceQuestion[];
}

export async function generateInterviewContent(config: {
    difficulty: string;
    dsaCount: number;
    vivaCount: number;
    type: string;
}): Promise<InterviewContent> {
    const apiKey = process.env.NEXT_PUBLIC_OPENROUTER_API_KEY;
    if (!apiKey || apiKey === 'your_key_here') {
        throw new Error("OpenRouter API key is missing. Please add it to .env.local.");
    }

    const prompt = `
    Generate professional coding interview content for a ${config.type} interview with ${config.difficulty} difficulty.
    
    REQUIRED CONTENT:
    ${config.dsaCount > 0 ? `1. ${config.dsaCount} DSA Questions. Each must have:
       - title
       - description (with technical constraints)
       - difficulty (${config.difficulty})
       - example (input and output strings)
       - testCases (at least 3 sample test cases as an array of {input, output} objects)` : '1. SKIP DSA Questions. Do not generate any coding challenges.'}
    
    2. ${config.vivaCount} Voice/Viva Questions. Each must have:
       - question
       - answer (concise but complete)

    RESPONSE FORMAT:
    You MUST respond with a valid JSON object only. Do not include any other text.
    Format:
    {
      "dsa": [
        ${config.dsaCount > 0 ? '{ "title": "...", "description": "...", "difficulty": "...", "example": { "input": "...", "output": "..." }, "testCases": [{ "input": "...", "output": "..." }] }' : ''}
      ],
      "voice": [
        { "question": "...", "answer": "..." }
      ]
    }
  `;

    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 60000); // Increased to 60s

    try {
        const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
            method: "POST",
            headers: {
                "Authorization": `Bearer ${apiKey}`,
                "Content-Type": "application/json",
                "HTTP-Referer": "http://localhost:3000",
                "X-Title": "SkillSphere Content Generator",
            },
            body: JSON.stringify({
                model: "xiaomi/mimo-v2-flash:free",
                messages: [{ role: "user", content: prompt }]
            }),
            signal: controller.signal
        });

        clearTimeout(timeoutId);

        if (!response.ok) {
            const errorText = await response.text();
            console.error("OpenRouter API Error:", response.status, errorText);
            throw new Error(`AI Service Error (${response.status}): ${errorText}`);
        }

        const data = await response.json();
        if (data.error) throw new Error(data.error.message || "AI Generation Failed");

        const rawContent = data.choices?.[0]?.message?.content || "{}";
        console.log("AI Raw Response:", rawContent);

        let cleanJson = rawContent;

        // Robust extraction: find the first '{' and last '}'
        const firstBrace = rawContent.indexOf('{');
        const lastBrace = rawContent.lastIndexOf('}');

        if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {
            cleanJson = rawContent.substring(firstBrace, lastBrace + 1);
        }

        try {
            const content = JSON.parse(cleanJson);
            return {
                dsa: content.dsa || [],
                voice: content.voice || []
            };
        } catch (parseError) {
            console.error("JSON Parse Error on:", cleanJson);
            throw parseError;
        }
    } catch (error: any) {
        clearTimeout(timeoutId);
        if (error.name === 'AbortError') {
            console.error("Content Generation Timed Out (60s)");
            throw new Error("AI Generation Timeout: The model is taking too long to respond. Standard mode enabled.");
        }
        console.error("Content Generation Error:", error);
        throw error;
    }
}

const generateDriverCode = (code: string, language: string, testCases: any[]) => {
    // Basic parser for inputs
    const parseInput = (inputStr: string) => {
        return inputStr.split(',').map(part => {
            const eqParts = part.split('=');
            return eqParts.length > 1 ? eqParts[1].trim() : eqParts[0].trim();
        }).join(', ');
    };

    if (language === 'javascript') {
        let driver = code + "\n\n// Driver Code\n";
        testCases.forEach((tc) => {
            driver += `try { console.log("---TEST-CASE-START---"); const res = solution(${parseInput(tc.input)}); console.log("---RVAL---"); console.log(JSON.stringify(res)); } catch(e) { console.log(e.message); }\n`;
        });
        return driver;
    } else if (language === 'python') {
        let driver = code + "\n\n# Driver Code\nimport json\n";
        testCases.forEach((tc) => {
            driver += `print("---TEST-CASE-START---")\ntry:\n    res = solution(${parseInput(tc.input)})\n    print("---RVAL---")\n    print(json.dumps(res))\nexcept Exception as e:\n    print(str(e))\n`;
        });
        return driver;
    } else if (language === 'cpp') {
        return code;
    }
    return code;
};

export async function evaluateCode(params: {
    code: string;
    language: string;
    testCases: Array<{ input: string; output: string }>;
    problemTitle: string;
}) {
    try {
        const fullCode = generateDriverCode(params.code, params.language, params.testCases);

        const response = await fetch("http://localhost:5000/api/execute", {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            },
            body: JSON.stringify({
                language: params.language,
                code: fullCode
            }),
        });

        if (!response.ok) {
            throw new Error(`Execution Service Error: ${response.statusText}`);
        }

        const data = await response.json();

        const rawOutput = data.run?.output || data.output || "";
        const exitCode = data.run?.code;

        const parts = rawOutput.split("---TEST-CASE-START---");
        // parts[0] is global stdout (before first test case)
        const globalStdout = parts[0].trim();

        const results = params.testCases.map((tc, index) => {
            const caseOutputRaw = parts[index + 1] || "";

            // Split into STDOUT and RVAL
            const [caseStdoutRaw, caseRvalRaw] = caseOutputRaw.split("---RVAL---");

            const caseStdout = caseStdoutRaw ? caseStdoutRaw.trim() : "";
            let actual = caseRvalRaw ? caseRvalRaw.trim() : "undefined";

            if (actual === "undefined" || actual === "null" || actual === "") {
                actual = "(nil)";
            }

            const expected = tc.output.trim();
            const passed = actual === expected || actual.replace(/\s/g, '') === expected.replace(/\s/g, '');

            return {
                input: tc.input,
                expected: expected,
                actual: actual,
                stdout: caseStdout,
                passed: passed
            };
        });

        const allPassed = results.every(r => r.passed) && exitCode === 0;

        return {
            success: allPassed,
            results: results,
            compilerOutput: globalStdout
        };

    } catch (error: any) {
        console.error("Evaluation Error:", error);
        return {
            success: false,
            results: [],
            compilerOutput: `Error executing code: ${error.message}`
        };
    }
}
